<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>老杨的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="老杨的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="老杨的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="oldyang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="老杨的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">老杨的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-代码里的世界观-通往架构师之路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/03/%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82-%E9%80%9A%E5%BE%80%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/" class="article-date">
  <time datetime="2021-06-03T14:54:51.000Z" itemprop="datePublished">2021-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/03/%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82-%E9%80%9A%E5%BE%80%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/">代码里的世界观,通往架构师之路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第1章-程序世界里的两个基本元素"><a href="#第1章-程序世界里的两个基本元素" class="headerlink" title="第1章 程序世界里的两个基本元素"></a>第1章 程序世界里的两个基本元素</h1><p>数据是目的,代码是手段,代码为数据服务<br>重构系统如果抓不住头绪,可以从数据的角度进行重新梳理和四孔</p>
<h1 id="第2章-面向对象的方式去理解世界"><a href="#第2章-面向对象的方式去理解世界" class="headerlink" title="第2章 面向对象的方式去理解世界"></a>第2章 面向对象的方式去理解世界</h1><p>特征： 封装 继承 多态 抽象</p>
<p>封装是为了解耦<br>继承是为了复用<br>多态是应对变化</p>
<p>类有了成员数据是有血有肉, 有了方法才是灵魂</p>
<p>封装和继承是构建多态的基础<br>多态是面向抽象编程的基石，有了多态，才能真正意义上进行“面向抽象，面向接口编程”</p>
<h1 id="第3章-面向抽象编程"><a href="#第3章-面向抽象编程" class="headerlink" title="第3章 面向抽象编程"></a>第3章 面向抽象编程</h1><p>数据的抽象—&gt; 面向抽象编程<br>代码的抽象—&gt; 面向接口编程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/03/%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82-%E9%80%9A%E5%BE%80%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/" data-id="ckph1ahd7000cq0nl2z6fho3o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何运用面向对象建模" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/10/%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1/" class="article-date">
  <time datetime="2021-04-10T07:50:59.000Z" itemprop="datePublished">2021-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/10/%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1/">如何运用面向对象建模</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>模型的直接构造成分是类，通过类以及类之间的关系描述整个系统</p>
</li>
<li><p>该思想来源与人类的日常思维方案：<br>  从个别事物上升到一般概念的归纳过程<br>  从一般到个别的演绎过程</p>
</li>
<li><p>在OOPL中<br>  类定义所有对象<br>  类创建对象实例</p>
</li>
<li><p>归纳：<br>  从对象出发认识问题域<br>  将问题域中的实物抽象为对象<br>  将具有共同特性的对象抽象为类用类以及他们之间的关系构成体系统模型</p>
</li>
<li><p>演绎<br>  在模型中用类表示属于该类的任何对象<br>  在类的规约中说明这个类创建的哪些对象实例</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/10/%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1/" data-id="ckph1ahda000hq0nlferka947" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Windows-多线程模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/05/Windows-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2021-04-05T10:49:42.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/05/Windows-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">Windows 多线程模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>用户级线程模型的优势是线程切换效率高，因为它不涉及系统内核模式和用户模式之间的切换；另一个好处是应用程序可以采用适合自己特点的线程选择算法，可以根据应用程序的逻辑来定义线程的优先级，当线程数量很大时，这一优势尤为明显。</p>
<p>内核级线程往往指操作系统提供的线程语义，由于操作系统对指令流有完全的控制能力，甚至可以通过硬件中断来强迫一个进程或线程暂停执行，以便把处理器时间移交给其他的进程或线程，所以，内核级线程有可能应用各种算法来分配处理器时间。线程可以有优先级，高优先级的线程被优先执行，它们可以抢占正在执行的低优先级线程。在支持线程语义的操作系统中，处理器的时间通常是按线程而非进程来分配，因此，系统有必要维护一个全局的线程表，在线程表中记录每个线程的寄存器、状态以及其他一些信息。然后，系统在适当的时候挂起一个正在执行的线程，选择一个新的线程在当前处理器上继续执行。</p>
<p>内核级线程的好处是，应用程序无须考虑是否要在适当的时候把控制权交给其他的线程，不必担心自己霸占处理器而导致其他线程得不到处理器时间。应用线程只要按照正常的指令流来实现自己的逻辑即可，内核会妥善地处理好线程之间共享处理器的资源分配问题。然而，这种对应用程序的便利也是有代价的，即，所有的线程切换都是在内核模式下完成的，因此，对于在用户模式下运行的线程来说，一个线程被切换出去，以及下次轮到它的时候再被切换进来，要涉及两次模式切换：从用户模式切换到内核模式，再从内核模式切换回用户模式。在Intel 的处理器上，这种模式切换大致需要几百个甚至上千个处理器指令周期。但是，随着处理器的硬件速度不断加快，模式切换的开销相对于现代操作系统的线程调度周期（通常几十毫秒）的比例正在减小，所以，这部分开销是完全可以接受的。</p>
<p>线程调度算法：<br>(1) 先到先服务算法。<br>(2) 时间片轮转调度算法。<br>(3) 优先级调度算法。</p>
<p>Windows 的调度算法是一个抢占式的、支持多处理器的优先级调度算法，它为每个处理器定义了一个链表数组，相同优先级的线程挂在同一个链表中，不同优先级的线程分别属于不同的链表。当一个线程满足了执行条件时，它首先被挂到当前处理器的一个待分配的链表（称为延迟的就绪链表）中，然后调度器会在适当的时候（当它获得了控制权时）把待分配链表上的线程分配到某个处理器的对应优先级的线程链表中。当这个处理器在选择下一个要运行的线程时，会根据优先级准则选择此线程（如果没有同等或更高优先级的线程也在等待运行的话）。Windows 中线程的优先级调整考虑到了很多因素，例如前台线程、等待I/O 完成后的线程也有轻微的优先级提升，这是一些来自实践经验的设计细节，它们使得Windows 操作系统对于交互式应用程序有更好的性能表现。</p>
<p>线程与进程的关系:</p>
<p>现在，我们来看一下线程与进程之间的关系。在不支持线程语义的系统中，进程提供了一个完全的执行环境，同时也有一个控制流完成其预定的功能，如图3.3(a)所示。操作系统按进程来分配处理器资源。在这种系统中，对线程的支持可以在用户模式下完成，即用户级线程模型，如图3.3(b)所示。在支持内核级线程的系统中，进程仅提供一个执行环境，它包含一个或者多个线程，每个线程代表一个单独的指令流，操作系统按线程来分配处理器资源，如图3.3(c)所示。Windows 中的线程是内核级线程，所以，它与进程之间的关系属于图3.3(c)所描述的情形。<br><img src="/2021/04/05/Windows-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/1.jpg" alt="www"></p>
<p>Windows NT和OS/2支持内核线程。Linux 支持内核级的多线程。</p>
<p>关于进程是否存在调度时间片？？？</p>
<p>我们看到了多个进程共享一个处理器时实际上是按照某种规则轮换执行的。当一个进程执行了一段时间以后，下一个进程被选出来占有处理器，继续它的指令流序列。这便是进程调度算法。如果一个操作系统支持内核级线程，那么，处理器资源的调度通常在线程而非进程粒度上进行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/05/Windows-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" data-id="ckph1ahcy0001q0nl3dsr0ra1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-高内聚-低耦合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/05/%E9%AB%98%E5%86%85%E8%81%9A-%E4%BD%8E%E8%80%A6%E5%90%88/" class="article-date">
  <time datetime="2021-04-05T10:33:42.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/05/%E9%AB%98%E5%86%85%E8%81%9A-%E4%BD%8E%E8%80%A6%E5%90%88/">高内聚 低耦合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="高内聚-低耦合"><a href="#高内聚-低耦合" class="headerlink" title="高内聚 低耦合"></a>高内聚 低耦合</h2><p>起因：耦合性与内聚性是模块独立性的两个定性度量标准，将软件系统划分模块时，每个模块只完成系统要求的独立子功能，并且与其他模块的联系最少且接口简单，提高模块的独立性，为设计高质量的软件结构奠定基础。</p>
<p>内聚：一个模块内各个元素彼此结合的紧密程度。<br>耦合：一个软件结构内不同模块之间互连程度的度量。<br>(耦合性也叫块间联系。指软件系统结构中个模块间相互联系紧密程度的一种度量。<br>模块之间联系越紧密，其耦合性就越强，模块的独立性则越差，模块间耦合的高低取决于模块间接口的复杂性，调用的方式以及传递的信息。)</p>
<p>低耦合，粗浅的理解<br>耦合性也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。</p>
<p>也就是说，让每个模块，尽可能的独立完成某个特定的子功能。 模块与模块之间的接口，尽量的少而简单。<br>如果某两个模块间的关系比较复杂的话，最好首先考虑进一步的模块划分。 这样有利于修改和组合。</p>
<p>高内聚，粗浅的理解<br>内聚性又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。</p>
<p>也就是充分利用每一个元素的功能，各施所能，以最终实现某个功能。<br>如果某个元素与该模块的关系比较疏松的话，可能该模块的结构还不够完善，或者是该元素是多余的。</p>
<p>分类<br>耦合性分类(低――高)<br>无直接耦合:<br>数据耦合: 指两个模块之间有调用关系，传递的是简单的数据值，相当于高级语言的值传递;<br>标记耦合: 指两个模块之间传递的是数据结构，如高级语言中的数组名、记录名、文件名等这些名字即标记，其实传递的是这个数据结构的地址;<br>控制耦合: 指一个模块调用另一个模块时，传递的是控制变量（如开关、标志等），被调模块通过该控制变量的值有选择地执行块内某一功能;<br>公共耦合: 指通过一个公共数据环境相互作用的那些模块间的耦合。公共耦合的复杂程序随耦合模块的个数增加而增加。<br>内容耦合: 这是最高程度的耦合，也是最差的耦合。当一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部。<br>内聚性分类(低――高)<br>偶然内聚: 指一个模块内的各处理元素之间没有任何联系。<br>逻辑内聚: 指模块内执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。<br>时间内聚: 把需要同时执行的动作组合在一起形成的模块为时间内聚模块。<br>通信内聚: 指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据。<br>顺序内聚: 指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。<br>功能内聚: 这是最强的内聚，指模块内所有元素共同完成一个功能，缺一不可。与其他模块的耦合是最弱的。<br>如何做到高内聚、低耦合<br>内聚和耦合，包含了横向和纵向的关系。功能内聚和数据耦合，是我们需要达成的目标。横向的内聚和耦合，通常体现在系统的各个模块、类之间的关系，而纵向的耦合，体现在系统的各个层次之间的关系。</p>
<p>对于我在编码中的困惑，我是这样想的，用面向对象的思想去考虑一个类的封装。 一个方法，如何封装，拿到现实生活中来看，看这种能力（方法）是否是属于这类事物（类）的本能。<br>如果是，就封装在这个类里。<br>如果不是，则考虑封装在其它类里。<br>如果这种能力，很多事物都具有，则一定要封装在这类事物的总类里。<br>如果这种能力，很多事物都会经常用到，则可以封装成一个总类的静态方法。</p>
<p>某些模块必然要关联起来才能工作，这是由业务逻辑决定的，不能否认。所以解耦并不是字面意义上的把关联拆掉，而是把模块之间的关联放松到必要的程度。一些建议：</p>
<p>模块只对外暴露最小限度的接口，形成最低的依赖关系。<br>只要对外接口不变，模块内部的修改，就不得影响其他模块；<br>删除一个模块，应当只影响有依赖关系的其他模块，而不应该影响其他无关部分；<br>软件工程有一条铁律“高内聚、低耦合”就是这个道理：必要的耦合不可否认，没有耦合程序就做不成事；但是不必要的紧耦合，就会让程序“牵一发而动全身”，最终让程序员的编写和维护都无从下手。</p>
<p>人类同一时间只能专注于一小部分的内容。“高内聚、低耦合”就是为了满足人类的这个特点——小尺度上只专注一个模块，局部的编码工作才能够进行。大尺度上把具体代码转化为一些抽象的“模块”和“依赖关系”，才能够抓大放小，把握住程序的脉络，拼合出一个完整的产品。</p>
<p>示例<br>有个例子很容易明白：一个程序有50个函数，这个程序执行得非常好；然而一旦你修改其中一个函数，其他49个函数都需要做修改，这就是高耦合的后果。</p>
<p>想象一下“社会大分工”这个模型——每一个小单位只专注自己的业务部分，与其他单位只存在业务外包的关联，以及物质、信息的交互。事实已经证明：这样的模型比以前大国企“大包大揽”自办各种职能部门的效率，有量级程度的提高。这就是“高内聚、低耦合”在现实世界中的体现。</p>
<p>总结<br>一旦你理解了它，你编写概要设计的时候设计类或者模块自然会考虑到“高内聚，低耦合”。<br>程序就是人类创造的第二世界，程序的逻辑无非是世界运行规律的抽象（面向对象比面向过程更加的切合现实世界）。跳出程序看程序，就会发现不一样的观点和角度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/05/%E9%AB%98%E5%86%85%E8%81%9A-%E4%BD%8E%E8%80%A6%E5%90%88/" data-id="ckph1ahdk000sq0nlhcoa4phm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/05/%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-04-05T10:32:36.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/05/%E7%AE%97%E6%B3%95/">算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>软件性能<br>有两个导致软件性能差的根本原因。</p>
<p>时间复杂度<br>解决这个问题很大程度上超出了本文的范围,一般可以这样说,时间复杂度是衡量一个程序需要做多少次的比较来实现一个结果。比较数量越多,程序越慢。一个简单的例子是线性查找与二分查找。线性查找对于同一组数据需要进行更多的比较,因此会慢。时间复杂度的详细讨论,请参考 维基百科文章。</p>
<p>空间复杂度<br>这是一台电脑运行你的解决方案需要多少“空间”或内存的测量。需要的内存越多,解决方案就越慢。本文将讨论的大多数问题,围绕空间复杂度。详细讨论,请参阅这里.。</p>
<p>为什么引用值要放在堆中，而原始值要放在栈中的问题：<br>记住一句话：能量是守衡的，无非是时间换空间，空间换时间的问题</p>
<p>堆比栈大，栈比堆的运算速度快，对象是一个复杂的结构，并且可以自由扩展，如：数组可以无限扩充，对象可以自由添加属性。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。<br>相对于简单数据类型而言，简单数据类型就比较稳定，并且它只占据很小的内存。</p>
<p>不将简单数据类型放在堆是因为通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本。<br>所以简单数据类型的值直接存放在栈中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/05/%E7%AE%97%E6%B3%95/" data-id="ckph1ahde000nq0nl3ac49dhr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-框架和设计模式的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/05/%E6%A1%86%E6%9E%B6%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2021-04-05T10:30:52.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/05/%E6%A1%86%E6%9E%B6%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/">框架和设计模式的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="框架和设计模式的区别"><a href="#框架和设计模式的区别" class="headerlink" title="框架和设计模式的区别"></a>框架和设计模式的区别</h2><p>有很多程序员往往把框架模式和设计模式混淆，认为MVC是一种设计模式。实际上它们完全是不同的概念。</p>
<p>框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。框架通常是代码重用，而设计模式是设计重用，架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。</p>
<p>在软件生产中有三种级别的重用：</p>
<p>内部重用，即在同一应用中能公共使用的抽象块；<br>代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；<br>应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。<br>框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示；设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。<br>框架模式有哪些？<br>MVC、MTV、MVP、CBD、ORM 等等；</p>
<p>框架有哪些？<br>C++语言的QT、MFC、gtk，Java语言的 SSH 、SSI，php语言的 smarty(MVC模式)，python语言的django(MTV模式)等等</p>
<p>设计模式有哪些？<br>工厂模式、适配器模式、策略模式等等</p>
<p>简而言之：框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/05/%E6%A1%86%E6%9E%B6%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="ckph1ahdc000lq0nlctdkdmz0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-io密集型和cpu密集型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/05/io%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8Ccpu%E5%AF%86%E9%9B%86%E5%9E%8B/" class="article-date">
  <time datetime="2021-04-05T10:11:34.000Z" itemprop="datePublished">2021-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/05/io%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8Ccpu%E5%AF%86%E9%9B%86%E5%9E%8B/">io密集型和cpu密集型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="如何设计CPU密集型与I-O密集型程序"><a href="#如何设计CPU密集型与I-O密集型程序" class="headerlink" title="如何设计CPU密集型与I/O密集型程序"></a>如何设计CPU密集型与I/O密集型程序</h2><p>核心是可以分别独立运行程序指令的计算单元。<br>线程是操作系统能够进行运算调度的最小单位。</p>
<p>有一个原则是：活跃线程数为 CPU(核)数时最佳。过少的活跃线程导致 CPU 无法被充分利用，过多的活跃线程导致过大的线程上下文切换开销。</p>
<p>总之：计算密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。</p>
<p>1.计算密集型线程池</p>
<p>cpu使用率较高（也就是一些复杂运算，逻辑处理），所以线程数一般只需要cpu核数的线程就可以了。 这一类型的在开发中多出现的一些业务复杂计算和逻辑处理过程中。</p>
<p>数量一般为 N+1个   N为CPU核心数</p>
<p>解决方案：</p>
<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
<p>多用来做计算、逻辑判断等cpu操作。可考虑通过消息队列或其他降维算法，将计算分散到不同的计算节点</p>
<p>对于计算密集型的需求，在开发过程中，需要注意计算算法的优化及结果重用，并尽可能进行降维处理，比如通过某种算法将原业务需求的计算分散成可拆分的逻辑，并分散计算进行结果求解，最后进行组合(很像现在大数据处理里的一些模式，可以参考)，或通过消息队列将大量的计算请求分发到其它的计算结点上去。</p>
<p>2.IO密集型</p>
<p>cpu使用率较低，程序中会存在大量I/O操作占据时间，导致线程空余时间出来，所以通常就需要开cpu核数的两倍的线程， 当线程进行I/O操作cpu空暇时启用其他线程继续使用cpu，提高cpu使用率 </p>
<p>通过上述可以总结出：最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目 线程等待时间所占比例越高，需要越多线程。(线程数等于IO任务数是最佳的)</p>
<p>线程CPU时间所占比例越高，需要越少线程。这一类型在开发中主要出现在一些读写操作频繁的业务逻辑中。<br>数量一般为：2N + 1个  N为CPU核心数</p>
<p>场景和解决方案<br>在服务器上进行网络通讯、网络传输、磁盘读写等均为IO操作，多为网络请求压力大、磁盘读写频繁的操作</p>
<p>io密集型的可能需要对磁盘进行升级、提高磁盘的相应速度和传输效率或通过负载技术将文件读写分散到多台服务器中；如果网络请求负载较高，可通过负载均衡技术、水平扩展提高负载。</p>
<p>于IO密集型的需求，在开发过程中，就要考虑尽可能减少IO开销，对磁盘读写频繁的业务，可以考虑通过内存缓存将热数据缓存起来，减少磁盘的请求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/05/io%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8Ccpu%E5%AF%86%E9%9B%86%E5%9E%8B/" data-id="ckph1ahd10004q0nlctuc5b3q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-经济" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/18/%E7%BB%8F%E6%B5%8E/" class="article-date">
  <time datetime="2021-01-18T14:47:56.000Z" itemprop="datePublished">2021-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/18/%E7%BB%8F%E6%B5%8E/">经济</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>经济学能教你把手头资源,比如钱,时间,用得更有效.</p>
<p>生产力：人类利用自然改造自然的能力</p>
<ul>
<li><p>谁来改造-&gt;劳动者————-&gt;人的因素</p>
<pre><code>             | 利用|</code></pre>
</li>
<li><p>怎么改造-&gt;生产工具———–&gt;物的因素</p>
<pre><code>             | 加工|    </code></pre>
</li>
<li><p>改造什么-&gt;劳动对象</p>
<p>生产资料：生产工具+劳动对象 （劳动对象不能构成生产力的因素，生产工具变革是社会生产力发展的主要标志）</p>
</li>
</ul>
<p>生产力的三要素包括劳动力、劳动工具、劳动对象,其中劳动力是最活跃的因素,劳动工具的变化即技术进步的快慢。<br>生产关系的三要素是生产资料的所有制；人们在生产中的地位和交换关系；产品的分配关系和它直接决定的消费关系</p>
<p>生产力决定生产关系，生产关系反作用于生产力<br>例子:<br>1.比如你要生产汽车，假设你有很多科技核心技术，那你只要有技术的操作人员，如果你什么都没有，那你所要请的员工就不一样了(虽然都是雇佣关系,但是却很不同)。<br>2.全民持股的生产关系,调用大家的工作积极性,促进生产力</p>
<p>价值：生成水-&gt;运输-&gt;销售-&gt;口渴的人<br>经济:  资源配置<br>经济周期: 繁荣期 危机期 再繁荣期</p>
<p>经济危机 金融危机:(郁金香泡沫,南海泡沫,美国大萧条)<br>答:不是产品过多的问题,就是钱过多的问题</p>
<p>亚洲金融危机:</p>
<ol>
<li>香港加息: 存款加息,贷款加息 -&gt; 大家都把钱存到银行,其他房地产等行业萧条</li>
</ol>
<p>金融危机中国如何转危为机遇:(内需)<br>高铁发展 电子商务发展：&gt;快递的发展-&gt;加速网购</p>
<p>经济规律：金融不稳定<br>经济好的时候借钱高投资，借钱多的还不上了，金融危机就来了</p>
<p>明斯基时刻：经济从好到坏的时间点</p>
<p>经济周期的三把火：<br>融资等于借钱<br>信贷：银行信任你未来能还钱，借给你钱<br>对冲性融资: 借钱搞投资，购买原材料，各行各业都有钱赚，市场形成良性循环 -&gt;表现经济增长<br>                  经济增长的初期,能换上本金和利息<br>                  产品没有过剩<br>投机性融资：放宽贷款条件,可以贷款更多-&gt;信贷扩展,   短期只归还利息,本金延后还<br>                  经济增长的中期,只能还得起本金<br>                 产品过剩的进程中<br>庞氏融资：盲目投资,同样的产品生产,需求增加,价格上涨,投资回报率低下<br>                拆东墙补西墙的旁氏骗局<br>                  经济进入衰退,本金和利息都还不上了</p>
<p>信贷紧缩: 银行借不出钱或不借钱了,借不到钱无法生产,消费不起,经济衰退</p>
<p>总结:<br>经济疯狂,主要是借钱越来越多,大家敢于冒险投资<br>杠杆:借钱的部分叫杠杠,杠杠过高还不起,引发危机</p>
<p>去杠杆,政府做三件事:</p>
<ol>
<li>资产重组<ul>
<li>少换点,延长还款时间</li>
</ul>
</li>
<li>财富再分配:<ul>
<li>给土豪加税,收来的钱发福利,创造就业</li>
</ul>
</li>
<li>货币调节:<ul>
<li>央行多印钱,</li>
</ul>
</li>
</ol>
<p>经济是什么?</p>
<ol>
<li>资源的优化配置,一瓶水只有到口渴的人口里才能发挥作用</li>
</ol>
<p>经济的形成:</p>
<ol>
<li>农业社会,大家自给自足,最后生产的产品越来越多,自己消费不掉,存起来,开始有了交互,产生了经济行为(人类的经济就是在重复交易中产生出来的)</li>
<li>工业设计,生产工具大大提升了生产里,社会分工明细,消费是最好的经济发展动力</li>
</ol>
<p>农业是骨架,工业是血肉,其他行业是器官. 他们一起组成了经济躯体<br>原材料,产品,服务,钱等资源,都在市场尚有条不紊的流动,去实现他们的价值,这就是经济大概</p>
<p>货币的起源:</p>
<ol>
<li>货币的起源,物物交换 -&gt; 选定中间物作为交换筹码(实物货币)</li>
<li>金属货币</li>
<li>信用产生了货币</li>
<li>纸币</li>
<li>电子货币</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/18/%E7%BB%8F%E6%B5%8E/" data-id="ckph1ahde000oq0nl5coe01bk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-如何让-VMWare-和-Hyper-V-共存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/17/%E5%A6%82%E4%BD%95%E8%AE%A9-VMWare-%E5%92%8C-Hyper-V-%E5%85%B1%E5%AD%98/" class="article-date">
  <time datetime="2021-01-17T02:59:56.000Z" itemprop="datePublished">2021-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/17/%E5%A6%82%E4%BD%95%E8%AE%A9-VMWare-%E5%92%8C-Hyper-V-%E5%85%B1%E5%AD%98/">如何让 VMWare 和 Hyper-V 共存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>将 Windows 版本升级到 Windows 10 20H1 或更高版本。</p>
</li>
<li><p>将 VMWare Workstation/Player 升级到 15.5.5 或更高版本，本文以 VMWare Player 为例。注意，在安装时，需要在如图所示的这一步勾选“自动安装 Windows Hypervisor Platform (WHP)”<br><img src="/2021/01/17/%E5%A6%82%E4%BD%95%E8%AE%A9-VMWare-%E5%92%8C-Hyper-V-%E5%85%B1%E5%AD%98/1.jpeg" alt="www"></p>
</li>
<li><p>运行 VMWare Workstation/Player，新建或导入虚拟机.</p>
</li>
<li><p>打开虚拟机的设置选项，找到“处理器”，去掉如图所示的三个选项前面的钩，点击“确定”<br><img src="/2021/01/17/%E5%A6%82%E4%BD%95%E8%AE%A9-VMWare-%E5%92%8C-Hyper-V-%E5%85%B1%E5%AD%98/2.jpeg" alt="www"></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/17/%E5%A6%82%E4%BD%95%E8%AE%A9-VMWare-%E5%92%8C-Hyper-V-%E5%85%B1%E5%AD%98/" data-id="ckph1ahda000gq0nlg4fk6z6s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-吴晓波-预见2021" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/03/%E5%90%B4%E6%99%93%E6%B3%A2-%E9%A2%84%E8%A7%812021/" class="article-date">
  <time datetime="2021-01-03T01:47:16.000Z" itemprop="datePublished">2021-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/03/%E5%90%B4%E6%99%93%E6%B3%A2-%E9%A2%84%E8%A7%812021/">吴晓波 预见2021</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h3><p>国货运动，方兴未艾<br>供应重构，产销分离<br>创新曲线陡峭，体验经济，美好爆发<br>过剩的市场，不再为必现品买单，为体验和服务买单<br>产业经济下行 货币宽松，“房住不炒”，钱去哪里了？ 资本市场，A股市场，权益类市场</p>
<h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><p>A股市场值得期待</p>
<p>中国经济的“三班车”<br>1.工业革命的“末班车”<br>  产能过剩-&gt;产业转型升级<br>2.互联网革命“头班车”<br>3.智能革命的“未来列车”</p>
<p>RCEP-&gt;产业升级<br>国货-&gt;品牌升级</p>
<p>8大预测：</p>
<ol>
<li><p>进口替代：<br>改革开放初期：以市场换技术，以时间换空间，最后实现全球第一制造业大国<br>互联网时代：模仿，小步迭代，试错快跑 最后完成替代<br>产业智能革命时代：引进型替代-&gt;自主型替代  应用型研发-&gt;基础型研发  数量扩张-&gt;质量型增长</p>
</li>
<li><p>云上中国<br>1998 门户：人与信息的关系<br>2003 淘宝：人与商品<br>2007 互联网金融：人与金融<br>2013 o2o: 人与服务<br>2016 新零售：人与空间</p>
<p>2016前：消费互联网<br>2016后：产业互联网 大数据，云计算，物联网，5G 改变城市治理和城市运营</p>
</li>
<li><p>生态赋能，范式继承</p>
</li>
<li><p>百万直播</p>
<ul>
<li>深入到社会的组织细胞和经济细胞的末梢部分（每个人 每个地方）</li>
<li>2021大概率，每个企业都有一个直播间</li>
</ul>
</li>
<li><p>品类流行替代品牌</p>
<ul>
<li>体验大于必现，颜值大于功能，口碑大于品宣</li>
</ul>
</li>
<li><p>购物中心即将消失</p>
</li>
<li><p>房产投资低空飞行</p>
</li>
<li><p>超级城市大赛鸣枪<br>京津冀  长三角 粤港澳</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/03/%E5%90%B4%E6%99%93%E6%B3%A2-%E9%A2%84%E8%A7%812021/" data-id="ckph1ahd8000eq0nlgmcsh8i2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/03/%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84%E4%B8%96%E7%95%8C%E8%A7%82-%E9%80%9A%E5%BE%80%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/">代码里的世界观,通往架构师之路</a>
          </li>
        
          <li>
            <a href="/2021/04/10/%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1/">如何运用面向对象建模</a>
          </li>
        
          <li>
            <a href="/2021/04/05/Windows-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">Windows 多线程模型</a>
          </li>
        
          <li>
            <a href="/2021/04/05/%E9%AB%98%E5%86%85%E8%81%9A-%E4%BD%8E%E8%80%A6%E5%90%88/">高内聚 低耦合</a>
          </li>
        
          <li>
            <a href="/2021/04/05/%E7%AE%97%E6%B3%95/">算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 oldyang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>